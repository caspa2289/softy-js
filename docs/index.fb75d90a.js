function t(t){return t&&t.__esModule?t.default:t}var e="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{},r={},i={},s=e.parcelRequireac70;null==s&&((s=function(t){if(t in r)return r[t].exports;if(t in i){var e=i[t];delete i[t];var s={id:t,exports:{}};return r[t]=s,e.call(s.exports,s,s.exports),s.exports}var o=Error("Cannot find module '"+t+"'");throw o.code="MODULE_NOT_FOUND",o}).register=function(t,e){i[t]=e},e.parcelRequireac70=s),(0,s.register)("kJlzD",function(t,e){Object.defineProperty(t.exports,"register",{get:function(){return r},set:function(t){return r=t},enumerable:!0,configurable:!0});var r,i=new Map;r=function(t,e){for(var r=0;r<e.length-1;r+=2)i.set(e[r],{baseUrl:t,path:e[r+1]})}}),s("kJlzD").register(new URL("",import.meta.url).toString(),JSON.parse('["81ar2","index.fb75d90a.js","73iMo","cubetexture.0f1795bd.jpg"]'));class o{constructor(t,e,r,i=1){this.x=t,this.y=e,this.z=r,this.w=i}add(t){return new o(this.x+t.x,this.y+t.y,this.z+t.z,this.w)}subtract(t){return new o(this.x-t.x,this.y-t.y,this.z-t.z,this.w)}}class a{constructor(t,e,r=1){this.u=t,this.v=e,this.w=r}}const n=[new a(0,0),new a(0,0),new a(0,0)];class h{constructor({vertexes:t,UVCoordinates:e=n,normal:r}){this._vertexes=t,this._UVCoordinates=e,this.normal=r}applyMatrixMut(t){return this.vertexes[0]=_(this.vertexes[0],t),this.vertexes[1]=_(this.vertexes[1],t),this.vertexes[2]=_(this.vertexes[2],t),this}normalizeInScreenSpaceMut(t,e){return(//account for perspective
this.UVCoordinates[0].u=this.UVCoordinates[0].u/this.vertexes[0].w,this.UVCoordinates[0].v=this.UVCoordinates[0].v/this.vertexes[0].w,this.UVCoordinates[0].w=1/this.vertexes[0].w,this.UVCoordinates[1].u=this.UVCoordinates[1].u/this.vertexes[1].w,this.UVCoordinates[1].v=this.UVCoordinates[1].v/this.vertexes[1].w,this.UVCoordinates[1].w=1/this.vertexes[1].w,this.UVCoordinates[2].u=this.UVCoordinates[2].u/this.vertexes[2].w,this.UVCoordinates[2].v=this.UVCoordinates[2].v/this.vertexes[2].w,this.UVCoordinates[2].w=1/this.vertexes[2].w,this.vertexes[0]=m(this.vertexes[0],1/this.vertexes[0].w),this.vertexes[1]=m(this.vertexes[1],1/this.vertexes[1].w),this.vertexes[2]=m(this.vertexes[2],1/this.vertexes[2].w),this.vertexes[0]=m(this.vertexes[0],-1),this.vertexes[1]=m(this.vertexes[1],-1),this.vertexes[2]=m(this.vertexes[2],-1),this.vertexes[0].x=(this.vertexes[0].x+1)*.5*t,this.vertexes[0].y=(this.vertexes[0].y+1)*.5*e,this.vertexes[1].x=(this.vertexes[1].x+1)*.5*t,this.vertexes[1].y=(this.vertexes[1].y+1)*.5*e,this.vertexes[2].x=(this.vertexes[2].x+1)*.5*t,this.vertexes[2].y=(this.vertexes[2].y+1)*.5*e,this)}getVertexCopies(){return this._vertexes.map(t=>new o(t.x,t.y,t.z,t.w))}getUVCoordinatesCopies(){return this._UVCoordinates.map(t=>new a(t.u,t.v,t.w))}getNormalCopy(){return this.normal?new o(this.normal.x,this.normal.y,this.normal.z,this.normal.w):void 0}getCopy(){return new h({vertexes:this.getVertexCopies(),UVCoordinates:this.getUVCoordinatesCopies(),normal:this.getNormalCopy()})}get vertexes(){return this._vertexes}get UVCoordinates(){return this._UVCoordinates}set vertexes(t){this._vertexes=t}set UVCoordinates(t){this._UVCoordinates=t}}const x=t=>Math.sqrt(w(t,t)),v=t=>{let e=x(t);return new o(t.x/e,t.y/e,t.z/e)},w=(t,e)=>t.x*e.x+t.y*e.y+t.z*e.z,u=(t,e)=>new o(t.y*e.z-t.z*e.y,t.z*e.x-t.x*e.z,t.x*e.y-t.y*e.x),l=t=>[[1,0,0,0],[0,Math.cos(t),Math.sin(t),0],[0,-Math.sin(t),Math.cos(t),0],[0,0,0,1]],d=t=>[[Math.cos(t),Math.sin(t),0,0],[-Math.sin(t),Math.cos(t),0,0],[0,0,1,0],[0,0,0,1]],p=t=>[[Math.cos(t),0,Math.sin(t),0],[0,1,0,0],[-Math.sin(t),0,Math.cos(t),0],[0,0,0,1]],c=(t,e,r)=>[[1,0,0,0],[0,1,0,0],[0,0,1,0],[t,e,r,1]],y=(t,e)=>{let r=d(t.z),i=l(t.x),s=p(t.y),o=c(e.x,e.y,e.z);//FIXME: зарефачить
return g(g(g(r,i),s),o)},_=(t,e)=>{let r=t.x*e[0][0]+t.y*e[1][0]+t.z*e[2][0]+t.w*e[3][0],i=t.x*e[0][1]+t.y*e[1][1]+t.z*e[2][1]+t.w*e[3][1],s=t.x*e[0][2]+t.y*e[1][2]+t.z*e[2][2]+t.w*e[3][2],a=t.x*e[0][3]+t.y*e[1][3]+t.z*e[2][3]+t.w*e[3][3];return new o(r,i,s,a)},g=(t,e)=>{let r=[[],[],[],[]];for(let i=0;i<4;i++)for(let s=0;s<4;s++)r[s][i]=t[s][0]*e[0][i]+t[s][1]*e[1][i]+t[s][2]*e[2][i]+t[s][3]*e[3][i];return r},f=(t,e,r,i)=>[[e.x,e.y,e.z,0],[r.x,r.y,r.z,0],[i.x,i.y,i.z,0],[t.x,t.y,t.z,1]],M=t=>[[t[0][0],t[1][0],t[2][0],0],[t[0][1],t[1][1],t[2][1],0],[t[0][2],t[1][2],t[2][2],0],[-(t[3][0]*t[0][0]+t[3][1]*t[0][1]+t[3][2]*t[0][2]),-(t[3][0]*t[1][0]+t[3][1]*t[1][1]+t[3][2]*t[1][2]),-(t[3][0]*t[2][0]+t[3][1]*t[2][1]+t[3][2]*t[2][2]),1]],m=(t,e)=>new o(t.x*e,t.y*e,t.z*e,t.w),z=(t,e,r,i)=>{let s=v(e),o=-w(s,t),a=w(r,s),n=w(i,s),h=(-o-a)/(n-a),x=i.subtract(r),u=m(x,h);return{vector:r.add(u),t:h}},C=(t,e,r)=>e.x*t.x+e.y*t.y+e.z*t.z-w(e,r),b=(t,e,r)=>{let i=v(e),s=[],o=[],n=[],x=[];switch(r.vertexes.forEach((e,a)=>{C(e,i,t)>=0?(s.push(e),n.push(r.UVCoordinates[a])):(o.push(e),x.push(r.UVCoordinates[a]))}),s.length){//Two sides of a triangle are clipped, create new triangle
case 1:{let i=z(t,e,s[0],o[0]),v=z(t,e,s[0],o[1]),w=new h({vertexes:[s[0],i.vector,v.vector],normal:r.normal,UVCoordinates:[n[0],new a(i.t*(x[0].u-n[0].u)+n[0].u,i.t*(x[0].v-n[0].v)+n[0].v,i.t*(x[0].w-n[0].w)+n[0].w),new a(v.t*(x[1].u-n[0].u)+n[0].u,v.t*(x[1].v-n[0].v)+n[0].v,v.t*(x[1].w-n[0].w)+n[0].w)]});return[w]}//One side of a triangle is clipped, divide resulting quad into two triangles
case 2:{let i=z(t,e,s[0],o[0]),v=z(t,e,s[1],o[0]),w=new h({vertexes:[s[0],s[1],i.vector],normal:r.normal,UVCoordinates:[n[0],n[1],new a(i.t*(x[0].u-n[0].u)+n[0].u,i.t*(x[0].v-n[0].v)+n[0].v,i.t*(x[0].w-n[0].w)+n[0].w)]}),u=new h({vertexes:[s[1],w.vertexes[2],v.vector],normal:r.normal,UVCoordinates:[n[1],w.UVCoordinates[2],new a(v.t*(x[0].u-n[1].u)+n[1].u,v.t*(x[0].v-n[1].v)+n[1].v,v.t*(x[0].w-n[1].w)+n[1].w)]});return[w,u]}// Triangle doesnt need clipping
case 3:return[r];// Triangle is completely clipped
default:return[]}},U=(t,e,r)=>{let{width:i,height:s}=t,o=Math.round(r*i),a=Math.round(e*s);return[t.data[a*(4*t.width)+4*o],t.data[a*(4*t.width)+4*o+1],t.data[a*(4*t.width)+4*o+2],t.data[a*(4*t.width)+4*o+3]]};class V{static rasterize(t,e,r,i,s){//FIXME: плейсхолдер
let a=window.camera,n=[{point:new o(0,0,0),normal:new o(0,1,0)},{point:new o(0,a.viewportHeight-1,0),normal:new o(0,-1,0)},{point:new o(0,0,0),normal:new o(1,0,0)},{point:new o(a.viewportWidth-1,0,0),normal:new o(-1,0,0)}];t.forEach(t=>{let h=y(t.rotation,t.position),x=s.createImageData(s.canvas.width,s.canvas.height);t.meshes?.forEach(t=>{let s=a.viewMatrix,l=t.triangles.reduce((t,n)=>{let x=n.getCopy();x.applyMatrixMut(h);let l=x.vertexes[1].subtract(x.vertexes[0]),d=x.vertexes[2].subtract(x.vertexes[0]),p=v(u(l,d)),c=w(p,x.vertexes[0].subtract(a.position));if(c>=0||isNaN(c))return t;x.applyMatrixMut(s);//Clip triangle against near plane
let y=b(new o(0,0,a.zNear),new o(0,0,1),x).map(t=>(t.normal=p,t.applyMatrixMut(e).normalizeInScreenSpaceMut(r,i)),[]);return[...t,...y]},[])//FIXME: нужно все треугольники в сцене сортировать, а не в меше
.sort((t,e)=>{let r=(t.vertexes[0].z+t.vertexes[1].z+t.vertexes[2].z)/3,i=(e.vertexes[0].z+e.vertexes[1].z+e.vertexes[2].z)/3;return i-r}),d=l;n.forEach(({point:t,normal:e})=>{d=d.reduce((r,i)=>[...r,...b(t,e,i)],[])}),d.forEach(e=>{this._generateTriangleData(e,x,t.texture)})}),s.putImageData(x,0,0)})}static _setPixelData(t,e,r,i){i.data[r*(4*i.width)+4*e]=t[0],i.data[r*(4*i.width)+4*e+1]=t[1],i.data[r*(4*i.width)+4*e+2]=t[2],i.data[r*(4*i.width)+4*e+3]=t[3]}static _generateTriangleData(t,e,r){//FIXME: потереть когда будет освещение
let i=new o(0,0,-1),s=v(i),{normal:a}=t,n=1;a&&(n=Math.max(w(s,a),.3));let h=[{x:t.vertexes[0].x,y:t.vertexes[0].y,u:t.UVCoordinates[0].u,v:t.UVCoordinates[0].v,w:t.UVCoordinates[0].w},{x:t.vertexes[1].x,y:t.vertexes[1].y,u:t.UVCoordinates[1].u,v:t.UVCoordinates[1].v,w:t.UVCoordinates[1].w},{x:t.vertexes[2].x,y:t.vertexes[2].y,u:t.UVCoordinates[2].u,v:t.UVCoordinates[2].v,w:t.UVCoordinates[2].w}].sort((t,e)=>t.y-e.y),x=h[1].y-h[0].y,u=h[1].x-h[0].x,l=h[1].v-h[0].v,d=h[1].u-h[0].u,p=h[1].w-h[0].w,c=h[2].y-h[0].y,y=h[2].x-h[0].x,_=h[2].v-h[0].v,g=h[2].u-h[0].u,f=h[2].w-h[0].w,M=0,m=0,z=0,C=0,b=0,V=0,R=0,A=0;if(x&&(M=u/Math.abs(x)),c&&(m=y/Math.abs(c)),x&&(z=d/Math.abs(x)),x&&(C=l/Math.abs(x)),x&&(R=p/Math.abs(x)),c&&(b=g/Math.abs(c)),c&&(V=_/Math.abs(c)),c&&(A=f/Math.abs(c)),x)for(let t=h[0].y;t<=h[1].y;t++){let i=h[0].x+(t-h[0].y)*M,s=h[0].x+(t-h[0].y)*m,o=0,a=0,x=0,v=h[0].u+(t-h[0].y)*z,w=h[0].v+(t-h[0].y)*C,u=h[0].w+(t-h[0].y)*R,l=h[0].u+(t-h[0].y)*b,d=h[0].v+(t-h[0].y)*V,p=h[0].w+(t-h[0].y)*A;i>s&&([i,s]=[s,i],[v,l]=[l,v],[w,d]=[d,w],[u,p]=[p,u]);let c=0,y=1/(s-i);o=v,a=w,x=u;for(let h=i;h<s;h++){//interpolated texture space values
o=(1-c)*v+c*l,a=(1-c)*w+c*d,x=(1-c)*u+c*p;let i=r?U(r,o/x,a/x):[255,255,255,255];this._setPixelData([i[0]*n,i[1]*n,i[2]*n,i[3]],Math.round(h),Math.round(t),e),c+=y}}if(x=h[2].y-h[1].y,u=h[2].x-h[1].x,l=h[2].v-h[1].v,d=h[2].u-h[1].u,p=h[2].w-h[1].w,x&&(M=u/Math.abs(x)),c&&(m=y/Math.abs(c)),z=0,C=0,x&&(z=d/Math.abs(x)),x&&(C=l/Math.abs(x)),x&&(R=p/Math.abs(x)),x)for(let t=h[1].y;t<=h[2].y;t++){let i=h[1].x+(t-h[1].y)*M,s=h[0].x+(t-h[0].y)*m,o=0,a=0,x=0,v=h[1].u+(t-h[1].y)*z,w=h[1].v+(t-h[1].y)*C,u=h[1].w+(t-h[1].y)*R,l=h[0].u+(t-h[0].y)*b,d=h[0].v+(t-h[0].y)*V,p=h[0].w+(t-h[0].y)*A;i>s&&([i,s]=[s,i],[v,l]=[l,v],[w,d]=[d,w],[u,p]=[p,u]),o=v,a=w,x=u;let c=1/(s-i),y=0;for(let h=i;h<s;h++){o=(1-y)*v+y*l,a=(1-y)*w+y*d,x=(1-y)*u+y*p;let i=r?U(r,o/x,a/x):[255,255,255,255];this._setPixelData([i[0]*n,i[1]*n,i[2]*n,i[3]],Math.round(h),Math.round(t),e),y+=c}}}}var R={};R="# Blender 4.0.2\r\n# www.blender.org\r\no Cube\r\nv 1.000000 1.000000 -1.000000\r\nv 1.000000 -1.000000 -1.000000\r\nv 1.000000 1.000000 1.000000\r\nv 1.000000 -1.000000 1.000000\r\nv -1.000000 1.000000 -1.000000\r\nv -1.000000 -1.000000 -1.000000\r\nv -1.000000 1.000000 1.000000\r\nv -1.000000 -1.000000 1.000000\r\nvt 0.875000 0.500000\r\nvt 0.625000 0.750000\r\nvt 0.625000 0.500000\r\nvt 0.375000 1.000000\r\nvt 0.375000 0.750000\r\nvt 0.625000 0.000000\r\nvt 0.375000 0.250000\r\nvt 0.375000 0.000000\r\nvt 0.375000 0.500000\r\nvt 0.125000 0.750000\r\nvt 0.125000 0.500000\r\nvt 0.625000 0.250000\r\nvt 0.875000 0.750000\r\nvt 0.625000 1.000000\r\ns 0\r\nf 5/1 3/2 1/3\r\nf 3/2 8/4 4/5\r\nf 7/6 6/7 8/8\r\nf 2/9 8/10 6/11\r\nf 1/3 4/5 2/9\r\nf 5/12 2/9 6/7\r\nf 5/1 7/13 3/2\r\nf 3/2 7/14 8/4\r\nf 7/6 5/12 6/7\r\nf 2/9 4/5 8/10\r\nf 1/3 3/2 4/5\r\nf 5/12 1/3 2/9\r\n";class A{constructor(t,e){this._triangles=t,this._texture=e}get triangles(){return this._triangles}set triangles(t){this._triangles=t}get texture(){return this._texture}set texture(t){this._texture=t}}var N={};N=new URL("cubetexture.0f1795bd.jpg",import.meta.url).toString();class F{constructor({rotation:t,position:e}){this._rotation=t,this._position=e,this._rotationXMatrix=this._newAxisRotationMatrix("x"),this._rotationYMatrix=this._newAxisRotationMatrix("y"),this._rotationZMatrix=this._newAxisRotationMatrix("z"),this._rotationMatrix=this._createRotationMatrix()}get rotationMatrix(){return this._rotationMatrix}get rotation(){return this._rotation}get position(){return this._position}set rotation(t){let e=this.rotation.x!==t.x,r=this.rotation.y!==t.y,i=this.rotation.z!==t.z;this._rotation=t,e&&this._updateAxisRotationMatrix("x"),r&&this._updateAxisRotationMatrix("y"),i&&this._updateAxisRotationMatrix("z"),(e||r||i)&&(this._rotationMatrix=this._createRotationMatrix())}set position(t){this._position=t}_createRotationMatrix(){return g(this._rotationXMatrix,g(this._rotationYMatrix,this._rotationZMatrix))}_updateAxisRotationMatrix(t){switch(t){case"x":this._rotationXMatrix=this._newAxisRotationMatrix(t);break;case"y":this._rotationYMatrix=this._newAxisRotationMatrix(t);break;case"z":this._rotationZMatrix=this._newAxisRotationMatrix(t)}}_newAxisRotationMatrix(t){switch(t){case"x":return l(this.rotation.x);case"y":return p(this.rotation.y);case"z":return d(this.rotation.z)}}}class E{constructor({rotation:t,position:e,meshes:r}){this._transform=new F({rotation:t,position:e}),this._meshes=r}get meshes(){return this._meshes}get transform(){return this._transform}get position(){return this._transform.position}get rotation(){return this._transform.rotation}set meshes(t){this._meshes=t}set position(t){this._transform.position=t}set rotation(t){this._transform.rotation=t}}//FIXME: верх почему-то -Y, скорее всего дело в том, что на канвасе отсчёт от левого верхнего угла идёт.
//Не уверен, что это проблема вообще
const H=new o(0,-1,0),D={viewportWidth:640,viewportHeight:480,zFar:1e3,zNear:.1,fov:75};class k extends E{constructor({rotation:t,position:e,options:r}){super({rotation:t,position:e}),this._forward=new o(0,0,1),this._viewportWidth=r?.viewportWidth??D.viewportWidth,this._viewportHeight=r?.viewportHeight??D.viewportHeight,this._zFar=r?.zFar??D.zFar,this._zNear=r?.zNear??D.zNear,this._fov=r?.fov??D.fov}get viewportWidth(){return this._viewportWidth}set viewportWidth(t){this._viewportWidth=t}get viewportHeight(){return this._viewportHeight}set viewportHeight(t){this._viewportHeight=t}get zFar(){return this._zFar}set zFar(t){this._zFar=t}get zNear(){return this._zNear}set zNear(t){this._zNear=t}set fov(t){this._fov=t}get fov(){return this._fov}get viewportAspectRatio(){return this._viewportHeight/this._viewportWidth}get fovRadians(){return 1/Math.tan(.5*this._fov/180*Math.PI)}setForwardDirection(t){this._forward=t}get localAxis(){let t=this.transform.rotationMatrix,e=_(this._forward,t),r=this.position.add(e),i=v(r.subtract(this.position)),s=v(H.subtract(m(i,w(H,i)))),o=u(s,i);return{forward:i,up:s,right:o,position:this.position}}get viewMatrix(){let{position:t,right:e,up:r,forward:i}=this.localAxis;return M(f(t,e,r,i))}}const S=document.getElementById("canvas"),W=S.getContext("2d"),I=new class extends k{constructor({rotation:t,position:e}){super({rotation:t,position:e})}}({position:new o(0,0,0),rotation:new o(0,0,0)});window.camera=I;const{viewportAspectRatio:K,fovRadians:T,zFar:P,zNear:q,viewportWidth:O,viewportHeight:j}=I,B=[[K*T,0,0,0],[0,T,0,0],[0,0,P/(P-q),1],[0,0,-P*q/(P-q),0]];window.addEventListener("keypress",t=>{let{forward:e,right:r,up:i}=I.localAxis;switch(t.code){case"KeyW":{let t=m(e,.1);I.position=I.position.add(t);break}case"KeyS":{let t=m(e,.1);I.position=I.position.subtract(t);break}case"KeyA":{let t=m(r,-.1);I.position=I.position.subtract(t);break}case"KeyD":{let t=m(r,-.1);I.position=I.position.add(t);break}case"KeyR":{let t=m(i,-.1);I.position=I.position.subtract(t);break}case"KeyF":{let t=m(i,-.1);I.position=I.position.add(t);break}case"KeyQ":I.rotation=new o(I.rotation.x,I.rotation.y+.1,I.rotation.z);break;case"KeyE":I.rotation=new o(I.rotation.x,I.rotation.y-.1,I.rotation.z)}});let L=0;const J=document.getElementById("fps");(class{static async _loadTextureData(){let e=await fetch(/*@__PURE__*/t(N)),r=await e.blob(),i=await createImageBitmap(r),s=document.createElement("canvas"),o=s.getContext("2d");return s.width=i.width,s.height=i.height,o.drawImage(i,0,0),o.getImageData(0,0,s.width,s.height)}//FIXME: сделать загрузку по урлу
static async loadFromUrl(){let e;let r=/*@__PURE__*/t(R).split("\n"),i=[],s=[{triangles:[]}],n=[],x=0;return r.forEach(t=>{if("o"===t[0]&&(s[++x]={triangles:[]}),"v"===t[0]){if("t"===t[1]){let e=t.split(" ");n.push(new a(Number(e[1]),Number(e[2])))}else{let e=t.split(" ");i.push(new o(Number(e[1]),Number(e[2]),Number(e[3])))}}}),r.forEach(t=>{if("f"===t[0]){if(0===n.length){let e=t.split(" ");s[x].triangles.push(new h({vertexes:[i[e[1]-1],i[e[2]-1],i[e[3]-1]],UVCoordinates:[new a(0,0),new a(0,0),new a(0,0)]}))}else{let e=t.split(" ").map(t=>t.split("/"));s[x].triangles.push(new h({vertexes:[i[e[1][0]-1],i[e[2][0]-1],i[e[3][0]-1]],UVCoordinates:[n[e[1][1]-1],n[e[2][1]-1],n[e[3][1]-1]]}))}}}),0!==n.length&&(e=await this._loadTextureData()),s.map(t=>new A(t.triangles,e))}}).loadFromUrl().then(t=>{let e=new E({rotation:new o(0,0,0),position:new o(0,0,6),meshes:t}),r=[e],i=t=>{//FIXME: добавить как дебаг функцию
J.textContent=`FPS: ${(1e3/(t-L)).toFixed(0)}`,L=t,e.rotation.x+=.01,e.rotation.y+=.01,V.rasterize(r,B,O,j,W),requestAnimationFrame(i)};requestAnimationFrame(i);// window.addEventListener('click', () => update(1))
});//# sourceMappingURL=index.fb75d90a.js.map

//# sourceMappingURL=index.fb75d90a.js.map
