{"mappings":"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","sources":["<anon>","src/main.ts","src/common/scripts.ts","src/common/Vector3D.ts","src/modules/Rasterizer.ts","src/modules/ObjLoader.ts","node_modules/@parcel/runtime-js/lib/bundles/runtime-8bfa33da05d44ebc.js","src/common/Triangle3D.ts","src/common/Mesh.ts"],"sourcesContent":["\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\nclass $c9d312133f17609a$export$fe203bd8c6486855 {\n    constructor(x, y, z){\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n}\n\n\nconst $e50145874b2b1376$export$5a8a2ab9d445df8 = (vec3D, matrix)=>{\n    const x = vec3D.x * matrix[0][0] + vec3D.y * matrix[1][0] + vec3D.z * matrix[2][0] + matrix[3][0];\n    const y = vec3D.x * matrix[0][1] + vec3D.y * matrix[1][1] + vec3D.z * matrix[2][1] + matrix[3][1];\n    const z = vec3D.x * matrix[0][2] + vec3D.y * matrix[1][2] + vec3D.z * matrix[2][2] + matrix[3][2];\n    const w = vec3D.x * matrix[0][3] + vec3D.y * matrix[1][3] + vec3D.z * matrix[2][3] + matrix[3][3];\n    if (w !== 0) return new (0, $c9d312133f17609a$export$fe203bd8c6486855)(x / w, y / w, z / w);\n    else return new (0, $c9d312133f17609a$export$fe203bd8c6486855)(x, y, z);\n};\nconst $e50145874b2b1376$export$1d64991cd669ebf9 = (aspectRatio, fovRad, zFar, zNear)=>{\n    return [\n        [\n            aspectRatio * fovRad,\n            0,\n            0,\n            0\n        ],\n        [\n            0,\n            fovRad,\n            0,\n            0\n        ],\n        [\n            0,\n            0,\n            zFar / (zFar - zNear),\n            1\n        ],\n        [\n            0,\n            0,\n            -zFar * zNear / (zFar - zNear),\n            0\n        ]\n    ];\n};\nconst $e50145874b2b1376$export$fc85d8c44b058d59 = (vector)=>{\n    return Math.sqrt(vector.x * vector.x + vector.y * vector.y + vector.z * vector.z);\n};\nconst $e50145874b2b1376$export$70da8fd9d46ea007 = (vector)=>{\n    const length = $e50145874b2b1376$export$fc85d8c44b058d59(vector);\n    return new (0, $c9d312133f17609a$export$fe203bd8c6486855)(vector.x / length, vector.y / length, vector.z / length);\n};\nconst $e50145874b2b1376$export$d269a5f7e82fc116 = (vec1, vec2)=>{\n    return vec1.x * vec2.x + vec1.y * vec2.y + vec1.z * vec2.z;\n};\n\n\n\n\nclass $3e58c13e710daa6e$export$56b36b3cdc60a1f9 {\n    static rasterize(data, projectionMatrix, sWidth, sHeight, context, time) {\n        context.fillStyle = \"black\";\n        context.fillRect(0, 0, sWidth, sHeight);\n        data.forEach((mesh)=>{\n            mesh.getVisibleTrisSortedByZ(projectionMatrix, sWidth, sHeight, time).forEach((triangle)=>{\n                this._drawTriangle(triangle, context);\n                //FIXME: вернуть как wireframe мод для дебага\n                context.fillStyle = \"green\";\n                for(let current = 0; current < triangle.vertexes.length; current++){\n                    const next = current === triangle.vertexes.length - 1 ? 0 : current + 1;\n                    this._drawLine(triangle.vertexes[current], triangle.vertexes[next], context);\n                }\n            });\n        });\n    }\n    static _drawLine(point0, point1, context) {\n        const { x: x0, y: y0 } = point0;\n        const { x: x1, y: y1 } = point1;\n        let dx = x1 - x0;\n        let dy = y1 - y0;\n        const step = Math.abs(dx) > Math.abs(dy) ? Math.abs(dx) : Math.abs(dy);\n        let [stepX, stepY] = [\n            x0,\n            y0\n        ];\n        dx /= step;\n        dy /= step;\n        for(let i = 0; i <= step; i++){\n            context.fillRect(Math.round(stepX), Math.round(stepY), 1, 1);\n            stepX += dx;\n            stepY += dy;\n        }\n    }\n    static _drawTriangle(triangle, context) {\n        //determine the triangle bounding box\n        const maxX = Math.max(triangle.vertexes[0].x, Math.max(triangle.vertexes[1].x, triangle.vertexes[2].x));\n        const minX = Math.min(triangle.vertexes[0].x, Math.min(triangle.vertexes[1].x, triangle.vertexes[2].x));\n        const maxY = Math.max(triangle.vertexes[0].y, Math.max(triangle.vertexes[1].y, triangle.vertexes[2].y));\n        const minY = Math.min(triangle.vertexes[0].y, Math.min(triangle.vertexes[1].y, triangle.vertexes[2].y));\n        //FIXME: потереть когда будет освещение\n        const lightPlaceholder = new (0, $c9d312133f17609a$export$fe203bd8c6486855)(0, 0, -1);\n        const normalizedLightVector = (0, $e50145874b2b1376$export$70da8fd9d46ea007)(lightPlaceholder);\n        const { normal: normal } = triangle;\n        if (normal) {\n            const dotProduct = (0, $e50145874b2b1376$export$d269a5f7e82fc116)(normalizedLightVector, normal);\n            const rgbValue = 255 * dotProduct;\n            context.fillStyle = `rgb(${rgbValue},${rgbValue},${rgbValue})`;\n        }\n        const vs1 = {\n            x: triangle.vertexes[1].x - triangle.vertexes[0].x,\n            y: triangle.vertexes[1].y - triangle.vertexes[0].y\n        };\n        const vs2 = {\n            x: triangle.vertexes[2].x - triangle.vertexes[0].x,\n            y: triangle.vertexes[2].y - triangle.vertexes[0].y\n        };\n        //FIXME: вынести куда-нибудь в утилиты и типизировать\n        const numCrossProduct2D = (vector1, vector2)=>{\n            return vector1.x * vector2.y - vector1.y * vector2.x;\n        };\n        for(let x = minX; x <= maxX; x++)for(let y = minY; y <= maxY; y++){\n            const q = {\n                x: x - triangle.vertexes[0].x,\n                y: y - triangle.vertexes[0].y\n            };\n            const s = numCrossProduct2D(q, vs2) / numCrossProduct2D(vs1, vs2);\n            const t = numCrossProduct2D(vs1, q) / numCrossProduct2D(vs1, vs2);\n            if (s >= 0 && t >= 0 && s + t <= 1) context.fillRect(Math.ceil(x), Math.ceil(y), 1, 1);\n        }\n    }\n}\n\n\nvar $de831eff6150fd71$exports = {};\n$de831eff6150fd71$exports = \"# Blender 4.0.2\\n# www.blender.org\\no Cube\\nv 1.112255 1.000000 -0.648811\\nv 0.586353 -1.000000 -0.586353\\nv 0.868856 1.000000 0.648811\\nv 0.586353 -1.000000 0.586353\\nv -1.112255 1.000000 -0.648811\\nv -0.586353 -1.000000 -0.586353\\nv -0.868856 1.000000 0.648811\\nv -0.586353 -1.000000 0.586353\\nv 1.992857 1.392449 -1.392449\\nv 1.992857 -1.392449 -1.392449\\nv 1.992857 1.392449 1.392449\\nv 1.992857 -1.392449 1.392449\\nv 3.192454 1.392449 -1.392449\\nv 3.192454 -1.392449 -1.392449\\nv 3.192454 1.392449 1.392449\\nv 3.192454 -1.392449 1.392449\\nv 4.084236 0.551429 -0.551429\\nv 4.084236 -0.551429 -0.551429\\nv 4.084236 0.551429 0.551429\\nv 4.084236 -0.551429 0.551429\\nv -2.129586 -1.523273 -1.523273\\nv -2.129586 -1.523273 1.523273\\nv -2.129586 1.523273 1.523273\\nv -2.129586 1.523273 -1.523273\\nv -3.385051 -1.523273 -1.523273\\nv -3.385051 -1.523273 1.523273\\nv -3.385051 1.523273 1.523273\\nv -3.385051 1.523273 -1.523273\\nv -4.542562 -0.527586 -0.527586\\nv -4.542562 -0.527586 0.527586\\nv -4.542562 0.527586 0.527586\\nv -4.542562 0.527586 -0.527586\\nv 0.648811 6.280553 0.648811\\nv -0.648811 6.280553 0.648811\\nv 0.648811 6.280553 -0.648811\\nv -0.648811 6.280553 -0.648811\\nv 0.983584 7.435852 0.983584\\nv -0.983584 7.435852 0.983584\\nv 0.983584 7.435852 -0.983584\\nv -0.983584 7.435852 -0.983584\\nv 0.549968 8.407492 0.549968\\nv -0.549968 8.407492 0.549968\\nv 0.549968 8.407492 -0.549968\\nv -0.549968 8.407492 -0.549968\\ns 0\\nf 7 36 5\\nf 3 8 4\\nf 5 23 7\\nf 2 8 6\\nf 1 11 9\\nf 5 2 6\\nf 11 13 9\\nf 3 12 11\\nf 1 10 2\\nf 2 12 4\\nf 13 18 14\\nf 9 14 10\\nf 10 16 12\\nf 12 15 11\\nf 17 20 18\\nf 14 20 16\\nf 16 19 15\\nf 15 17 13\\nf 21 28 24\\nf 5 21 24\\nf 7 22 8\\nf 8 21 6\\nf 28 31 27\\nf 22 25 21\\nf 24 27 23\\nf 23 26 22\\nf 31 29 30\\nf 27 30 26\\nf 25 32 28\\nf 26 29 25\\nf 36 39 35\\nf 3 35 33\\nf 5 35 1\\nf 3 34 7\\nf 38 44 40\\nf 35 37 33\\nf 34 40 36\\nf 33 38 34\\nf 44 41 43\\nf 37 42 38\\nf 40 43 39\\nf 39 41 37\\nf 7 34 36\\nf 3 7 8\\nf 5 24 23\\nf 2 4 8\\nf 1 3 11\\nf 5 1 2\\nf 11 15 13\\nf 3 4 12\\nf 1 9 10\\nf 2 10 12\\nf 13 17 18\\nf 9 13 14\\nf 10 14 16\\nf 12 16 15\\nf 17 19 20\\nf 14 18 20\\nf 16 20 19\\nf 15 19 17\\nf 21 25 28\\nf 5 6 21\\nf 7 23 22\\nf 8 22 21\\nf 28 32 31\\nf 22 26 25\\nf 24 28 27\\nf 23 27 26\\nf 31 32 29\\nf 27 31 30\\nf 25 29 32\\nf 26 30 29\\nf 36 40 39\\nf 3 1 35\\nf 5 36 35\\nf 3 33 34\\nf 38 42 44\\nf 35 39 37\\nf 34 38 40\\nf 33 37 38\\nf 44 42 41\\nf 37 41 42\\nf 40 44 43\\nf 39 43 41\\n\";\n\n\n\n\n\nclass $04f3dddf70873dfc$export$33863bdf254c6c3 {\n    constructor({ vertexes: vertexes, normal: normal }){\n        this._vertexes = vertexes;\n        this.normal = normal;\n    }\n    getScreenSpaceProjection(projectionMatrix, sWidth, sHeight, time) {\n        //FIXME: зарефачить\n        const triangle = this.getWorldSpaceProjection(projectionMatrix, time);\n        if (!triangle) return null;\n        triangle.vertexes[0].x = (triangle.vertexes[0].x + 1) * 0.5 * sWidth;\n        triangle.vertexes[0].y = (triangle.vertexes[0].y + 1) * 0.5 * sHeight;\n        triangle.vertexes[1].x = (triangle.vertexes[1].x + 1) * 0.5 * sWidth;\n        triangle.vertexes[1].y = (triangle.vertexes[1].y + 1) * 0.5 * sHeight;\n        triangle.vertexes[2].x = (triangle.vertexes[2].x + 1) * 0.5 * sWidth;\n        triangle.vertexes[2].y = (triangle.vertexes[2].y + 1) * 0.5 * sHeight;\n        return triangle;\n    }\n    getWorldSpaceProjection(projectionMatrix, time) {\n        const translatedTriangle = new $04f3dddf70873dfc$export$33863bdf254c6c3({\n            vertexes: this.getVertexCopies()\n        });\n        /**FILLER**/ const zRotationMatrix = [\n            [\n                Math.cos(time),\n                Math.sin(time),\n                0,\n                0\n            ],\n            [\n                -Math.sin(time),\n                Math.cos(time),\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                1,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                1\n            ]\n        ];\n        const xRotationMatrix = [\n            [\n                1,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                Math.cos(time * 0.5),\n                Math.sin(time * 0.5),\n                0\n            ],\n            [\n                0,\n                -Math.sin(time * 0.5),\n                Math.cos(time * 0.5),\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                1\n            ]\n        ];\n        translatedTriangle.vertexes[0] = (0, $e50145874b2b1376$export$5a8a2ab9d445df8)(translatedTriangle.vertexes[0], xRotationMatrix), translatedTriangle.vertexes[1] = (0, $e50145874b2b1376$export$5a8a2ab9d445df8)(translatedTriangle.vertexes[1], xRotationMatrix), translatedTriangle.vertexes[2] = (0, $e50145874b2b1376$export$5a8a2ab9d445df8)(translatedTriangle.vertexes[2], xRotationMatrix);\n        translatedTriangle.vertexes[0] = (0, $e50145874b2b1376$export$5a8a2ab9d445df8)(translatedTriangle.vertexes[0], zRotationMatrix), translatedTriangle.vertexes[1] = (0, $e50145874b2b1376$export$5a8a2ab9d445df8)(translatedTriangle.vertexes[1], zRotationMatrix), translatedTriangle.vertexes[2] = (0, $e50145874b2b1376$export$5a8a2ab9d445df8)(translatedTriangle.vertexes[2], zRotationMatrix);\n        /**FILLER**/ //FIXME: убрать когда будет камера\n        translatedTriangle.vertexes[0].z += 12;\n        translatedTriangle.vertexes[1].z += 12;\n        translatedTriangle.vertexes[2].z += 12;\n        const line1 = new (0, $c9d312133f17609a$export$fe203bd8c6486855)(translatedTriangle.vertexes[1].x - translatedTriangle.vertexes[0].x, translatedTriangle.vertexes[1].y - translatedTriangle.vertexes[0].y, translatedTriangle.vertexes[1].z - translatedTriangle.vertexes[0].z);\n        const line2 = new (0, $c9d312133f17609a$export$fe203bd8c6486855)(translatedTriangle.vertexes[2].x - translatedTriangle.vertexes[0].x, translatedTriangle.vertexes[2].y - translatedTriangle.vertexes[0].y, translatedTriangle.vertexes[2].z - translatedTriangle.vertexes[0].z);\n        const normalizedX = line1.y * line2.z - line1.z * line2.y;\n        const normalizedY = line1.z * line2.x - line1.x * line2.z;\n        const normalizedZ = line1.x * line2.y - line1.y * line2.x;\n        const normalLength = Math.sqrt(normalizedX * normalizedX + normalizedY * normalizedY + normalizedZ * normalizedZ);\n        const normal = new (0, $c9d312133f17609a$export$fe203bd8c6486855)(normalizedX / normalLength, normalizedY / normalLength, normalizedZ / normalLength);\n        //FIXME: плейсхолдер\n        const camera = new (0, $c9d312133f17609a$export$fe203bd8c6486855)(0, 0, 0);\n        const cameraDotProduct = normal.x * (translatedTriangle.vertexes[0].x - camera.x) + normal.y * (translatedTriangle.vertexes[0].y - camera.y) + normal.z * (translatedTriangle.vertexes[0].z - camera.z);\n        if (cameraDotProduct > 0 || isNaN(cameraDotProduct)) return null;\n        return new $04f3dddf70873dfc$export$33863bdf254c6c3({\n            //FIXME: refactor\n            vertexes: [\n                //FIXME: венруть this когда будет камера\n                (0, $e50145874b2b1376$export$5a8a2ab9d445df8)(translatedTriangle.vertexes[0], projectionMatrix),\n                (0, $e50145874b2b1376$export$5a8a2ab9d445df8)(translatedTriangle.vertexes[1], projectionMatrix),\n                (0, $e50145874b2b1376$export$5a8a2ab9d445df8)(translatedTriangle.vertexes[2], projectionMatrix)\n            ],\n            normal: normal\n        });\n    }\n    getVertexCopies() {\n        return this._vertexes.map((vertex)=>{\n            return new (0, $c9d312133f17609a$export$fe203bd8c6486855)(vertex.x, vertex.y, vertex.z);\n        });\n    }\n    get vertexes() {\n        return this._vertexes;\n    }\n    set vertexes(value) {\n        this._vertexes = value;\n    }\n}\n\n\nclass $aa552dc8a9341dec$export$e176487c05830cc5 {\n    constructor(triangles){\n        this._triangles = triangles;\n    }\n    getVisibleTrisSortedByZ(projectionMatrix, sWidth, sHeight, time) {\n        //FIXME: заменить на toSorted() когда он в тс заедет\n        const trianglesCopy = [\n            ...this.getVisibleTris(projectionMatrix, sWidth, sHeight, time)\n        ];\n        trianglesCopy.sort((t0, t1)=>{\n            const averageZ0 = (t0.vertexes[0].z + t0.vertexes[1].z + t0.vertexes[2].z) / 3;\n            const averageZ1 = (t1.vertexes[0].z + t1.vertexes[1].z + t1.vertexes[2].z) / 3;\n            return Number(averageZ0 > averageZ1);\n        });\n        return trianglesCopy;\n    }\n    getVisibleTris(projectionMatrix, sWidth, sHeight, time) {\n        return this._triangles.reduce((res, triangle)=>{\n            const projectedTriangle = triangle.getScreenSpaceProjection(projectionMatrix, sWidth, sHeight, time);\n            return projectedTriangle ? [\n                ...res,\n                projectedTriangle\n            ] : res;\n        }, []);\n    }\n    get triangles() {\n        return this._triangles;\n    }\n    set triangles(value) {\n        this._triangles = value;\n    }\n}\n\n\nclass $52da8439c771a3d7$export$2fa3e0ea900f8e74 {\n    //FIXME: сделать загрузку по урлу\n    static loadFromUrl() {\n        const data = (0, (/*@__PURE__*/$parcel$interopDefault($de831eff6150fd71$exports))).split(\"\\n\");\n        const vertexes = [];\n        const rawData = [];\n        let current = 0;\n        data.forEach((line)=>{\n            if (line[0] === \"o\") {\n                current++;\n                rawData[current] = {\n                    triangles: []\n                };\n            }\n            if (line[0] === \"v\") {\n                const data = line.split(\" \");\n                vertexes.push(new (0, $c9d312133f17609a$export$fe203bd8c6486855)(data[1], data[2], data[3]));\n            }\n        });\n        data.forEach((line)=>{\n            if (line[0] === \"f\") {\n                const data = line.split(\" \");\n                rawData[current].triangles.push(new (0, $04f3dddf70873dfc$export$33863bdf254c6c3)({\n                    vertexes: [\n                        vertexes[data[1] - 1],\n                        vertexes[data[2] - 1],\n                        vertexes[data[3] - 1]\n                    ]\n                }));\n            }\n        });\n        return rawData.map((data)=>{\n            return new (0, $aa552dc8a9341dec$export$e176487c05830cc5)(data.triangles);\n        });\n    }\n}\n\n\nconst $deded05a08b16674$var$CANVAS = document.getElementById(\"canvas\");\nconst $deded05a08b16674$var$CONTEXT = $deded05a08b16674$var$CANVAS.getContext(\"2d\");\nconst $deded05a08b16674$var$WIDTH = 640;\nconst $deded05a08b16674$var$HEIGHT = 480;\nconst $deded05a08b16674$var$ASPECT_RATIO = $deded05a08b16674$var$HEIGHT / $deded05a08b16674$var$WIDTH;\nconst $deded05a08b16674$var$Z_FAR = 1000;\nconst $deded05a08b16674$var$Z_NEAR = 0.1;\nconst $deded05a08b16674$var$FOV = 90;\nconst $deded05a08b16674$var$FOV_RADIANS = 1 / Math.tan($deded05a08b16674$var$FOV * 0.5 / 180 * Math.PI);\nconst $deded05a08b16674$var$projectionMatrix = (0, $e50145874b2b1376$export$1d64991cd669ebf9)($deded05a08b16674$var$ASPECT_RATIO, $deded05a08b16674$var$FOV_RADIANS, $deded05a08b16674$var$Z_FAR, $deded05a08b16674$var$Z_NEAR);\nconst $deded05a08b16674$var$testData = (0, $52da8439c771a3d7$export$2fa3e0ea900f8e74).loadFromUrl();\nconst $deded05a08b16674$var$update = (time)=>{\n    (0, $3e58c13e710daa6e$export$56b36b3cdc60a1f9).rasterize($deded05a08b16674$var$testData, $deded05a08b16674$var$projectionMatrix, $deded05a08b16674$var$WIDTH, $deded05a08b16674$var$HEIGHT, $deded05a08b16674$var$CONTEXT, time / 1000);\n    requestAnimationFrame($deded05a08b16674$var$update);\n};\nrequestAnimationFrame($deded05a08b16674$var$update);\n\n\n//# sourceMappingURL=index.4624b037.js.map\n","import { getProjectionMatrix } from './common/scripts'\nimport { Rasterizer } from './modules/Rasterizer'\nimport { ObjLoader } from './modules/ObjLoader'\nimport { Mesh } from './common/Mesh'\n\nconst CANVAS = document.getElementById('canvas') as HTMLCanvasElement\nconst CONTEXT = CANVAS.getContext('2d')\nconst WIDTH = 640\nconst HEIGHT = 480\nconst ASPECT_RATIO = HEIGHT / WIDTH\nconst Z_FAR = 1000\nconst Z_NEAR = 0.1\nconst FOV = 90\nconst FOV_RADIANS = 1 / Math.tan(FOV * 0.5 / 180 * Math.PI)\n\nconst projectionMatrix = getProjectionMatrix(ASPECT_RATIO, FOV_RADIANS, Z_FAR, Z_NEAR)\n\nconst testData = ObjLoader.loadFromUrl()\n\nconst update = (time: number) => {\n    Rasterizer.rasterize(testData as Mesh[], projectionMatrix, WIDTH, HEIGHT, CONTEXT, time / 1000)\n\n    requestAnimationFrame(update)\n}\n\nrequestAnimationFrame(update)\n","import { Vector3D } from './Vector3D'\nimport { Matrix } from './types'\n\nexport const multiplyMatrixByVector = (vec3D: Vector3D, matrix: Matrix) => {\n    const x = vec3D.x * matrix[0][0] + vec3D.y * matrix[1][0] + vec3D.z * matrix[2][0] + matrix[3][0]\n    const y = vec3D.x * matrix[0][1] + vec3D.y * matrix[1][1] + vec3D.z * matrix[2][1] + matrix[3][1]\n    const z = vec3D.x * matrix[0][2] + vec3D.y * matrix[1][2] + vec3D.z * matrix[2][2] + matrix[3][2]\n    const w = vec3D.x * matrix[0][3] + vec3D.y * matrix[1][3] + vec3D.z * matrix[2][3] + matrix[3][3]\n\n    if (w !== 0) {\n        return new Vector3D(x/w, y/w, z/w)\n    } else {\n        return new Vector3D(x, y, z)\n    }\n}\n\nexport const getProjectionMatrix = (\n    aspectRatio: number,\n    fovRad: number,\n    zFar: number,\n    zNear: number\n): Matrix => {\n    return [\n        [ aspectRatio * fovRad, 0, 0, 0 ],\n        [ 0, fovRad, 0, 0 ],\n        [ 0, 0, zFar / (zFar - zNear), 1 ],\n        [ 0, 0, (-zFar * zNear) / (zFar - zNear), 0 ],\n    ]\n}\n\nexport const getLengthVector3D = (vector: Vector3D) => {\n    return Math.sqrt(vector.x * vector.x + vector.y * vector.y + vector.z * vector.z)\n}\n\nexport const normalizeVector3D = (vector: Vector3D) => {\n    const length = getLengthVector3D(vector)\n\n    return new Vector3D(vector.x / length, vector.y / length, vector.z / length)\n}\n\nexport const getDotProduct3D = (vec1: Vector3D, vec2: Vector3D) => {\n    return  vec1.x * vec2.x + vec1.y * vec2.y + vec1.z * vec2.z\n}\n","export class Vector3D {\n    x: number\n    y: number\n    z: number\n\n    constructor(x: number, y: number, z: number) {\n        this.x = x\n        this.y = y\n        this.z = z\n    }\n}\n","import { Mesh } from '../common/Mesh'\nimport { Vector3D } from '../common/Vector3D'\nimport { Matrix } from '../common/types'\nimport { Triangle3D } from '../common/Triangle3D'\nimport { getDotProduct3D, normalizeVector3D } from '../common/scripts'\n\nexport class Rasterizer {\n    static rasterize(\n        data: Mesh[],\n        projectionMatrix: Matrix,\n        sWidth: number,\n        sHeight: number,\n        context: CanvasRenderingContext2D,\n        time: number\n    ) {\n        context.fillStyle = 'black'\n        context.fillRect(0, 0, sWidth, sHeight)\n        data.forEach((mesh) => {\n            mesh.getVisibleTrisSortedByZ(projectionMatrix, sWidth, sHeight, time)\n                .forEach((triangle) => {\n                    this._drawTriangle(triangle, context)\n\n                    //FIXME: вернуть как wireframe мод для дебага\n                    context.fillStyle = 'green'\n                    for (let current = 0; current < triangle.vertexes.length; current++) {\n                        const next = current === triangle.vertexes.length - 1 ? 0 : current + 1\n\n                        this._drawLine(triangle.vertexes[current], triangle.vertexes[next], context)\n                    }\n                })\n        })\n    }\n\n    static _drawLine(point0: Vector3D, point1: Vector3D, context: CanvasRenderingContext2D) {\n        const { x: x0, y: y0 } = point0\n        const { x: x1, y: y1 } = point1\n\n        let dx = x1 - x0\n        let dy = y1 - y0\n\n        const step = Math.abs(dx) > Math.abs(dy) ? Math.abs(dx) : Math.abs(dy)\n        let [ stepX, stepY ] = [ x0, y0 ]\n\n        dx /= step\n        dy /= step\n\n        for (let i = 0; i <= step; i++) {\n            context.fillRect(Math.round(stepX), Math.round(stepY), 1, 1)\n            stepX += dx\n            stepY += dy\n        }\n    }\n\n    static _drawTriangle(triangle: Triangle3D, context: CanvasRenderingContext2D) { //Barycentric Algorithm\n        //determine the triangle bounding box\n        const maxX = Math.max(triangle.vertexes[0].x, Math.max(triangle.vertexes[1].x, triangle.vertexes[2].x))\n        const minX = Math.min(triangle.vertexes[0].x, Math.min(triangle.vertexes[1].x, triangle.vertexes[2].x))\n        const maxY = Math.max(triangle.vertexes[0].y, Math.max(triangle.vertexes[1].y, triangle.vertexes[2].y))\n        const minY = Math.min(triangle.vertexes[0].y, Math.min(triangle.vertexes[1].y, triangle.vertexes[2].y))\n\n        //FIXME: потереть когда будет освещение\n        const lightPlaceholder = new Vector3D(0, 0, -1)\n        const normalizedLightVector = normalizeVector3D(lightPlaceholder)\n\n        const { normal } = triangle\n\n        if (normal) {\n            const dotProduct = getDotProduct3D(normalizedLightVector, normal)\n\n            const rgbValue = 255 * dotProduct\n            context.fillStyle = `rgb(${rgbValue},${rgbValue},${rgbValue})`\n        }\n\n        const vs1 = {\n            x: triangle.vertexes[1].x - triangle.vertexes[0].x,\n            y: triangle.vertexes[1].y - triangle.vertexes[0].y\n        }\n        const vs2 = {\n            x: triangle.vertexes[2].x - triangle.vertexes[0].x,\n            y: triangle.vertexes[2].y - triangle.vertexes[0].y\n        }\n\n        //FIXME: вынести куда-нибудь в утилиты и типизировать\n        const numCrossProduct2D = (vector1: { x: number, y: number }, vector2: { x: number, y: number }): number => {\n            return (vector1.x * vector2.y) - (vector1.y * vector2.x)\n        }\n\n        for (let x = minX; x <= maxX; x++)\n        {\n            for (let y = minY; y <= maxY; y++)\n            {\n                const q = { x: x - triangle.vertexes[0].x, y: y - triangle.vertexes[0].y }\n\n                const s = numCrossProduct2D(q, vs2) / numCrossProduct2D(vs1, vs2)\n                const t = numCrossProduct2D(vs1, q) / numCrossProduct2D(vs1, vs2)\n\n                if ((s >= 0) && (t >= 0) && (s + t <= 1))\n                {\n                    context.fillRect(Math.ceil(x), Math.ceil(y), 1, 1)\n                }\n            }\n        }\n    }\n}\n","import testModel from 'bundle-text:../testModel.obj'\nimport { Vector3D } from '../common/Vector3D'\nimport { Triangle3D } from '../common/Triangle3D'\nimport { Mesh } from '../common/Mesh'\n\nexport class ObjLoader {\n    //FIXME: сделать загрузку по урлу\n    static loadFromUrl (): Mesh[] | null {\n        const data = testModel.split('\\n')\n\n        const vertexes: Vector3D[] = []\n\n        const rawData: { triangles: Triangle3D[] }[] = []\n\n        let current = 0\n\n        data.forEach((line) => {\n            if (line[0] === 'o') {\n                current++\n                rawData[current] = { triangles: [] }\n            }\n\n            if (line[0] === 'v') {\n                const data = line.split(' ')\n                vertexes.push(new Vector3D(data[1], data[2], data[3]))\n            }\n        })\n\n        data.forEach((line) => {\n            if (line[0] === 'f') {\n                const data = line.split(' ')\n                rawData[current].triangles.push(new Triangle3D({\n                    vertexes: [\n                        vertexes[data[1] - 1],\n                        vertexes[data[2] - 1],\n                        vertexes[data[3] - 1],\n                    ]\n                }))\n            }\n        })\n\n        return rawData.map((data) => {\n            return new Mesh(data.triangles)\n        })\n    }\n}\n","module.exports = \"60818aad22076c51\";","import { Vector3D } from './Vector3D'\nimport { Matrix } from './types'\nimport { multiplyMatrixByVector } from './scripts'\n\nexport class Triangle3D {\n    _vertexes: Vector3D[]\n    normal?: Vector3D\n\n    constructor({ vertexes, normal = undefined }) {\n        this._vertexes = vertexes\n        this.normal = normal\n    }\n\n    getScreenSpaceProjection(projectionMatrix: Matrix, sWidth: number, sHeight: number, time: number) {\n        //FIXME: зарефачить\n        const triangle = this.getWorldSpaceProjection(projectionMatrix, time)\n\n        if (!triangle) return null\n\n        triangle.vertexes[0].x = (triangle.vertexes[0].x + 1) * 0.5 * sWidth\n        triangle.vertexes[0].y = (triangle.vertexes[0].y + 1) * 0.5 * sHeight\n        triangle.vertexes[1].x = (triangle.vertexes[1].x + 1) * 0.5 * sWidth\n        triangle.vertexes[1].y = (triangle.vertexes[1].y + 1) * 0.5 * sHeight\n        triangle.vertexes[2].x = (triangle.vertexes[2].x + 1) * 0.5 * sWidth\n        triangle.vertexes[2].y = (triangle.vertexes[2].y + 1) * 0.5 * sHeight\n\n        return triangle\n    }\n\n    getWorldSpaceProjection(projectionMatrix: Matrix, time: number) {\n\n        const translatedTriangle = new Triangle3D({\n            vertexes: this.getVertexCopies()\n        })\n\n        /**FILLER**/\n        const zRotationMatrix = [\n            [ Math.cos(time), Math.sin(time), 0, 0 ],\n            [ -Math.sin(time), Math.cos(time), 0, 0 ],\n            [ 0, 0, 1, 0 ],\n            [ 0, 0, 0, 1 ],\n        ]\n\n        const xRotationMatrix = [\n            [ 1, 0, 0, 0 ],\n            [ 0, Math.cos(time * 0.5), Math.sin(time * 0.5), 0 ],\n            [ 0, -Math.sin(time * 0.5), Math.cos(time * 0.5), 0 ],\n            [ 0, 0, 0, 1 ],\n        ]\n\n        translatedTriangle.vertexes[0] = multiplyMatrixByVector(translatedTriangle.vertexes[0], xRotationMatrix),\n        translatedTriangle.vertexes[1] = multiplyMatrixByVector(translatedTriangle.vertexes[1], xRotationMatrix),\n        translatedTriangle.vertexes[2] = multiplyMatrixByVector(translatedTriangle.vertexes[2], xRotationMatrix)\n\n        translatedTriangle.vertexes[0] = multiplyMatrixByVector(translatedTriangle.vertexes[0], zRotationMatrix),\n        translatedTriangle.vertexes[1] = multiplyMatrixByVector(translatedTriangle.vertexes[1], zRotationMatrix),\n        translatedTriangle.vertexes[2] = multiplyMatrixByVector(translatedTriangle.vertexes[2], zRotationMatrix)\n\n        /**FILLER**/\n\n        //FIXME: убрать когда будет камера\n        translatedTriangle.vertexes[0].z += 12\n        translatedTriangle.vertexes[1].z += 12\n        translatedTriangle.vertexes[2].z += 12\n\n        const line1 = new Vector3D(\n            translatedTriangle.vertexes[1].x - translatedTriangle.vertexes[0].x,\n            translatedTriangle.vertexes[1].y - translatedTriangle.vertexes[0].y,\n            translatedTriangle.vertexes[1].z - translatedTriangle.vertexes[0].z,\n        )\n\n        const line2 = new Vector3D(\n            translatedTriangle.vertexes[2].x - translatedTriangle.vertexes[0].x,\n            translatedTriangle.vertexes[2].y - translatedTriangle.vertexes[0].y,\n            translatedTriangle.vertexes[2].z - translatedTriangle.vertexes[0].z,\n        )\n\n        const normalizedX = (line1.y * line2.z) - (line1.z * line2.y)\n        const normalizedY = (line1.z * line2.x) - (line1.x * line2.z)\n        const normalizedZ = (line1.x * line2.y) - (line1.y * line2.x)\n        const normalLength = Math.sqrt(normalizedX * normalizedX + normalizedY * normalizedY + normalizedZ * normalizedZ)\n\n        const normal = new Vector3D(\n            normalizedX / normalLength,\n            normalizedY / normalLength,\n            normalizedZ / normalLength)\n\n        //FIXME: плейсхолдер\n        const camera = new Vector3D(0, 0, 0)\n\n        const cameraDotProduct =\n            normal.x * (translatedTriangle.vertexes[0].x - camera.x) +\n            normal.y * (translatedTriangle.vertexes[0].y - camera.y) +\n            normal.z * (translatedTriangle.vertexes[0].z - camera.z)\n\n        if (cameraDotProduct > 0 || isNaN(cameraDotProduct)) {\n            return null\n        }\n\n        return new Triangle3D({\n            //FIXME: refactor\n            vertexes: [\n                //FIXME: венруть this когда будет камера\n                multiplyMatrixByVector(translatedTriangle.vertexes[0], projectionMatrix),\n                multiplyMatrixByVector(translatedTriangle.vertexes[1], projectionMatrix),\n                multiplyMatrixByVector(translatedTriangle.vertexes[2], projectionMatrix)\n            ],\n            normal\n        })\n    }\n\n    getVertexCopies() {\n        return this._vertexes.map((vertex) => {\n            return new Vector3D(vertex.x, vertex.y, vertex.z)\n        })\n    }\n\n    get vertexes() {\n        return this._vertexes\n    }\n\n    set vertexes(value) {\n        this._vertexes = value\n    }\n}\n","import { Triangle3D } from './Triangle3D'\nimport {Matrix} from './types'\n\nexport class Mesh {\n    _triangles: Triangle3D[]\n\n    constructor(triangles: Triangle3D[]) {\n        this._triangles = triangles\n    }\n\n    public getVisibleTrisSortedByZ(projectionMatrix: Matrix, sWidth: number, sHeight: number, time: number) {\n        //FIXME: заменить на toSorted() когда он в тс заедет\n        const trianglesCopy = [ ...this.getVisibleTris(projectionMatrix, sWidth, sHeight, time) ]\n\n        trianglesCopy.sort((t0, t1) => {\n            const averageZ0 = (t0.vertexes[0].z + t0.vertexes[1].z + t0.vertexes[2].z) / 3\n            const averageZ1 = (t1.vertexes[0].z + t1.vertexes[1].z + t1.vertexes[2].z) / 3\n\n            return Number(averageZ0 > averageZ1)\n        })\n\n        return trianglesCopy\n    }\n\n    public getVisibleTris(projectionMatrix: Matrix, sWidth: number, sHeight: number, time: number) {\n        return this._triangles.reduce((res, triangle) => {\n            const projectedTriangle = triangle.getScreenSpaceProjection(projectionMatrix, sWidth, sHeight, time)\n\n            return projectedTriangle ? [ ...res, projectedTriangle ] : res\n\n        }, [] as Triangle3D[])\n    }\n\n    get triangles() {\n        return this._triangles\n    }\n\n    set triangles(value) {\n        this._triangles = value\n    }\n}\n"],"names":["$c9d312133f17609a$export$fe203bd8c6486855","constructor","x","y","z","$e50145874b2b1376$export$5a8a2ab9d445df8","vec3D","matrix","w","$e50145874b2b1376$export$fc85d8c44b058d59","vector","Math","sqrt","$e50145874b2b1376$export$70da8fd9d46ea007","length","$e50145874b2b1376$export$d269a5f7e82fc116","vec1","vec2","$3e58c13e710daa6e$export$56b36b3cdc60a1f9","rasterize","data","projectionMatrix","sWidth","sHeight","context","time","fillStyle","fillRect","forEach","mesh","getVisibleTrisSortedByZ","triangle","_drawTriangle","current","vertexes","next","_drawLine","point0","point1","x0","y0","x1","y1","dx","dy","step","abs","stepX","stepY","i","round","maxX","max","minX","min","maxY","minY","lightPlaceholder","normalizedLightVector","normal","dotProduct","rgbValue","vs1","vs2","numCrossProduct2D","vector1","vector2","q","s","t","ceil","fovRad","$de831eff6150fd71$exports","$04f3dddf70873dfc$export$33863bdf254c6c3","_vertexes","getScreenSpaceProjection","getWorldSpaceProjection","translatedTriangle","getVertexCopies","zRotationMatrix","cos","sin","xRotationMatrix","line1","line2","normalizedX","normalizedY","normalizedZ","normalLength","camera","cameraDotProduct","isNaN","map","vertex","value","$aa552dc8a9341dec$export$e176487c05830cc5","triangles","_triangles","trianglesCopy","getVisibleTris","sort","t0","t1","averageZ0","averageZ1","Number","reduce","res","projectedTriangle","$deded05a08b16674$var$CANVAS","document","getElementById","$deded05a08b16674$var$CONTEXT","getContext","$deded05a08b16674$var$projectionMatrix","aspectRatio","$deded05a08b16674$var$HEIGHT","tan","$deded05a08b16674$var$FOV","PI","zFar","$deded05a08b16674$var$testData","loadFromUrl","a","__esModule","default","split","rawData","line","push","$deded05a08b16674$var$update","requestAnimationFrame"],"version":3,"file":"index.4624b037.js.map"}